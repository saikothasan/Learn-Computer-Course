<h1>Virtual Memory in Operating System</h1>
<p>Virtual Memory is a storage allocation scheme in which secondary memory can be addressed as though it were part of main memory. The addresses a program may use to reference memory are distinguished from the addresses the memory system uses to identify physical storage sites, and program generated addresses are translated automatically to the corresponding machine addresses.<br />The size of virtual storage is limited by the addressing scheme of the computer system and amount of secondary memory is available not by the actual number of the main storage locations.</p>
<p>It is a technique that is implemented using both hardware and software. It maps memory addresses used by a program, called virtual addresses, into physical addresses in computer memory.</p>
<ol>
<li>All memory references within a process are logical addresses that are dynamically translated into physical addresses at run time. This means that a process can be swapped in and out of main memory such that it occupies different places in main memory at different times during the course of execution.</li>
<li>A process may be broken into number of pieces and these pieces need not be continuously located in the main memory during execution. The combination of dynamic run-time address translation and use of page or segment table permits this.</li>
</ol>
<p>If these characteristics are present then, it is not necessary that all the pages or segments are present in the main memory during execution. This means that the required pages need to be loaded into memory whenever required. Virtual memory is implemented using Demand Paging or Demand Segmentation.</p>
<p><strong>Demand Paging :</strong><br />The process of loading the page into memory on demand (whenever page fault occurs) is known as demand paging.<br />The process includes the following steps :</p>
<ol>
<li>If CPU try to refer a page that is currently not available in the main memory, it generates an interrupt indicating memory access fault.</li>
<li>The OS puts the interrupted process in a blocking state. For the execution to proceed the OS must bring the required page into the memory.</li>
<li>The OS will search for the required page in the logical address space.</li>
<li>The required page will be brought from logical address space to physical address space. The page replacement algorithms are used for the decision making of replacing the page in physical address space.</li>
<li>The page table will updated accordingly.</li>
<li>The signal will be sent to the CPU to continue the program execution and it will place the process back into ready state.</li>
</ol>
<p>Hence whenever a page fault occurs these steps are followed by the operating system and the required page is brought into memory.</p>
<p><strong>Advantages :</strong></p>
<ul style="list-style-type: circle;">
<li>More processes may be maintained in the main memory: Because we are going to load only some of the pages of any particular process, there is room for more processes. This leads to more efficient utilization of the processor because it is more likely that at least one of the more numerous processes will be in the ready state at any particular time.</li>
<li>A process may be larger than all of main memory: One of the most fundamental restrictions in programming is lifted. A process larger than the main memory can be executed because of demand paging. The OS itself loads pages of a process in main memory as required.</li>
<li>It allows greater multiprogramming levels by using less of the available (primary) memory for each process.</li>
</ul>
<p><strong>Page Fault Service Time :</strong><br />The time taken to service the page fault is called as page fault service time. The page fault service time includes the time taken to perform all the above six steps.</p>
<p><strong>Swapping:</strong></p>
<p>Swapping a process out means removing all of its pages from memory, or marking them so that they will be removed by the normal page replacement process. Suspending a process ensures that it is not runnable while it is swapped out. At some later time, the system swaps back the process from the secondary storage to main memory. When a process is busy swapping pages in and out then this situation is called thrashing.</p>
<p><strong>Causes of Thrashing :</strong></p>
<ol>
<li><strong>High degree of multiprogramming&nbsp;</strong>: If the number of processes keeps on increasing in the memory than number of frames allocated to each process will be decreased. So, less number of frames will be available to each process. Due to this, page fault will occur more frequently and more CPU time will be wasted in just swapping in and out of pages and the utilization will keep on decreasing.
<p>For example:<br />Let free frames = 400<br /><strong>Case 1</strong>: Number of process = 100<br />Then, each process will get 4 frames.</p>
<p><strong>Case 2</strong>: Number of process = 400<br />Each process will get 1 frame.<br />Case 2 is a condition of thrashing, as the number of processes are increased,frames per process are decreased. Hence CPU time will be consumed in just swapping pages.</p>
</li>
<li><strong>Lacks of Frames</strong>:If a process has less number of frames then less pages of that process will be able to reside in memory and hence more frequent swapping in and out will be required. This may lead to thrashing. Hence sufficient amount of frames must be allocated to each process in order to prevent thrashing.</li>
</ol>
<p><strong>Recovery of Thrashing :</strong></p>
<ul style="list-style-type: circle;">
<li>Do not allow the system to go into thrashing by instructing the long term scheduler not to bring the processes into memory after the threshold.</li>
<li>If the system is already in thrashing then instruct the mid term schedular to suspend some of the processes so that we can recover the system from thrashing.</li>
</ul>
<p>&nbsp;</p>